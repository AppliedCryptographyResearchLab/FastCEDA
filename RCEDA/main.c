#include "params.h"
#include "blake2.h"
#include "aes.h"
 
#include "math.h"

#include <gmp.h>




// ======== RSA Stuff 











#define MODULUS_SIZE 3072                   /* This is the number of bits we want in the modulus */
#define BLOCK_SIZE (MODULUS_SIZE/8)         /* This is the size of a block that gets en/decrypted at once */
#define BUFFER_SIZE ((MODULUS_SIZE/8) / 2)  /* This is the number of bytes in n and p */

typedef struct {
    mpz_t n; /* Modulus */
    mpz_t e; /* Public Exponent */
} public_key;

typedef struct {
    mpz_t n; /* Modulus */
    mpz_t e; /* Public Exponent */
    mpz_t d; /* Private Exponent */
    mpz_t p; /* Starting prime p */
    mpz_t q; /* Starting prime q */
} private_key;

void print_hex(char* arr, int len)
{
    int i;
    for(i = 0; i < len; i++)
        printf("%02x", (unsigned char) arr[i]);
}

/* NOTE: Assumes mpz_t's are initted in ku and kp */
void generate_keys(private_key* ku, public_key* kp)
{
    char buf[BUFFER_SIZE];
    int i;
    mpz_t phi; mpz_init(phi);
    mpz_t tmp1; mpz_init(tmp1);
    mpz_t tmp2; mpz_init(tmp2);

    srand(time(NULL));

    /* Insetead of selecting e st. gcd(phi, e) = 1; 1 < e < phi, lets choose e
     * first then pick p,q st. gcd(e, p-1) = gcd(e, q-1) = 1 */
    // We'll set e globally.  I've seen suggestions to use primes like 3, 17 or
    // 65537, as they make coming calculations faster.  Lets use 3.
    mpz_set_ui(ku->e, 65537);

    /* Select p and q */
    /* Start with p */
    // Set the bits of tmp randomly
    for(i = 0; i < BUFFER_SIZE; i++)
        buf[i] = rand() % 0xFF;
    // Set the top two bits to 1 to ensure int(tmp) is relatively large
    buf[0] |= 0xC0;
    // Set the bottom bit to 1 to ensure int(tmp) is odd (better for finding primes)
    buf[BUFFER_SIZE - 1] |= 0x01;
    // Interpret this char buffer as an int
    mpz_import(tmp1, BUFFER_SIZE, 1, sizeof(buf[0]), 0, 0, buf);
    // Pick the next prime starting from that random number
    mpz_nextprime(ku->p, tmp1);
    /* Make sure this is a good choice*/
    mpz_mod(tmp2, ku->p, ku->e);        /* If p mod e == 1, gcd(phi, e) != 1 */
    while(!mpz_cmp_ui(tmp2, 1))
    {
        mpz_nextprime(ku->p, ku->p);    /* so choose the next prime */
        mpz_mod(tmp2, ku->p, ku->e);
    }

    /* Now select q */
    do {
        for(i = 0; i < BUFFER_SIZE; i++)
            buf[i] = rand() % 0xFF;
        // Set the top two bits to 1 to ensure int(tmp) is relatively large
        buf[0] |= 0xC0;
        // Set the bottom bit to 1 to ensure int(tmp) is odd
        buf[BUFFER_SIZE - 1] |= 0x01;
        // Interpret this char buffer as an int
        mpz_import(tmp1, (BUFFER_SIZE), 1, sizeof(buf[0]), 0, 0, buf);
        // Pick the next prime starting from that random number
        mpz_nextprime(ku->q, tmp1);
        mpz_mod(tmp2, ku->q, ku->e);
        while(!mpz_cmp_ui(tmp2, 1))
        {
            mpz_nextprime(ku->q, ku->q);
            mpz_mod(tmp2, ku->q, ku->e);
        }
    } while(mpz_cmp(ku->p, ku->q) == 0); /* If we have identical primes (unlikely), try again */

    /* Calculate n = p x q */
    mpz_mul(ku->n, ku->p, ku->q);

    /* Compute phi(n) = (p-1)(q-1) */
    mpz_sub_ui(tmp1, ku->p, 1);
    mpz_sub_ui(tmp2, ku->q, 1);
    mpz_mul(phi, tmp1, tmp2);

    /* Calculate d (multiplicative inverse of e mod phi) */
    if(mpz_invert(ku->d, ku->e, phi) == 0)
    {
        mpz_gcd(tmp1, ku->e, phi);
        printf("gcd(e, phi) = [%s]\n", mpz_get_str(NULL, 16, tmp1));
        printf("Invert failed\n");
    }

    /* Set public key */
    mpz_set(kp->e, ku->e);
    mpz_set(kp->n, ku->n);

    return;
}

void block_encrypt(mpz_t C, mpz_t M, public_key kp)
{
    /* C = M^e mod n */
    mpz_powm(C, M, kp.e, kp.n);
    return;
}

int encrypt(char cipher[], char message[], int length, public_key kp)
{
    /* Its probably overkill, but I implemented PKCS#1v1.5 paging
     * Encoded message block is of the form:
     * EMB = 00 || 02 || PS || 00 || D
     * Where || is concatenation, D is the message, and PS is a string of
     * (block_size-|D|-3) non-zero, randomly generated bytes
     * |D| must be less than block_size - 11, which means we have at least 8
     * bytes of PS
     */
    int block_count = 0;
    int prog = length;
    char mess_block[BLOCK_SIZE];
    mpz_t m; mpz_init(m);
    mpz_t c; mpz_init(c);

    while(prog > 0)
    {
        int i = 0;
        int d_len = (prog >= (BLOCK_SIZE - 11)) ? BLOCK_SIZE - 11 : prog;

        /* Construct the header */
        mess_block[i++] = 0x00;
        mess_block[i++] = 0x02;
        while(i < (BLOCK_SIZE - d_len - 1))
            mess_block[i++] = (rand() % (0xFF - 1)) + 1;
        mess_block[i++] = 0x00;

        /* Copy in the message */
        memcpy(mess_block + i, message + (length - prog), d_len);

        // Convert bytestream to integer
        mpz_import(m, BLOCK_SIZE, 1, sizeof(mess_block[0]), 0, 0, mess_block);
        // Perform encryption on that block
        block_encrypt(c, m, kp);

        // Calculate cipher write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = block_count * BLOCK_SIZE;         // Base offset to start of this block
        off += (BLOCK_SIZE - (mpz_sizeinbase(c, 2) + 8 - 1)/8); // See manual for mpz_export

        // Pull out bytestream of ciphertext
        mpz_export(cipher + off, NULL, 1, sizeof(char), 0, 0, c);

        block_count++;
        prog -= d_len;
    }
    return block_count * BLOCK_SIZE;
}

void block_decrypt(mpz_t M, mpz_t C, private_key ku)
{
    mpz_powm(M, C, ku.d, ku.n);
    return;
}

int decrypt(char* message, char* cipher, int length, private_key ku)
{
    int msg_idx = 0;
    char buf[BLOCK_SIZE];
    *(long long*)buf = 0ll;
    mpz_t c; mpz_init(c);
    mpz_t m; mpz_init(m);

    int i;
    for(i = 0; i < (length / BLOCK_SIZE); i++)
    {
        // Pull block into mpz_t
        mpz_import(c, BLOCK_SIZE, 1, sizeof(char), 0, 0, cipher + i * BLOCK_SIZE);
        // Decrypt block
        block_decrypt(m, c, ku);

        // Calculate message write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = (BLOCK_SIZE - (mpz_sizeinbase(m, 2) + 8 - 1)/8); // See manual for mpz_export
        // Convert back to bitstream
        mpz_export(buf + off, NULL, 1, sizeof(char), 0, 0, m);

        // Now we just need to lop off top padding before memcpy-ing to message
        // We know the first 2 bytes are 0x00 and 0x02, so manually skip those
        // After that, increment forward till we see a zero byte
        int j;
        for(j = 2; ((buf[j] != 0) && (j < BLOCK_SIZE)); j++);
        j++;        // Skip the 00 byte

        /* Copy over the message part of the plaintext to the message return var */
        memcpy(message + msg_idx, buf + j, BLOCK_SIZE - j);

        msg_idx += BLOCK_SIZE - j;
    }
    return msg_idx;
}




//  ==================== RSA Code 





int main(int argc, char **argv)
{
    private_key ku;
    public_key kp;
    // Initialize public key
    mpz_init(kp.n);
    mpz_init(kp.e);
    // Initialize private key
    mpz_init(ku.n);
    mpz_init(ku.e);
    mpz_init(ku.d);
    mpz_init(ku.p);
    mpz_init(ku.q);
	unsigned char sk[16] = {0x54, 0xa2, 0xf8, 0x03, 0x1d, 0x18, 0xac, 0x77, 0xd2, 0x53, 0x92, 0xf2, 0x80, 0xb4, 0xb1, 0x2f};
    generate_keys(&ku, &kp);

	block key;
	block* prf_out;
    uint16_t* prf_out2;
	prf_out = malloc(8*16);
	prf_out2 = malloc(8*16);
	
    unsigned char z[32] = {0x54, 0xa2, 0xf8, 0x03, 0x1d, 0x18, 0xac, 0x77, 0xd2, 0x53, 0x92, 0xf2, 0x80, 0xb4, 0xb1, 0x2f, 0xac, 0xf1, 0x29, 0x3f, 0x3a, 0xe6, 0x77, 0x7d, 0x74, 0x15, 0x67, 0x91, 0x99, 0x53, 0x69, 0xc5};
    mpz_t c_pk[1024];

	uint64_t ii ,i;
	ii = 1;
	i = 0;

	//CHANGED FROM 32 TO 64 BIT UINT
	//xi, temp, rPrime
	

	// initialize the aes function with the key sk
	key = toBlock((uint8_t*)sk);
	setKey(key);
	uint64_t index;
    uint64_t index_v;

	uint64_t counter = 1025;
    
    
    // =========================== KeyGen 
    
    mpz_t mpz_prf; // value to hold the prf output before enc in keyGen
    mpz_init(mpz_prf);
    
    
    
    
    
    for (i = 0;i<1024;i++){
      //  printf("\n\n\n for i =%d \n\n\n",i);
        ecbEncCounterMode(i,1,prf_out);
        memcpy(prf_out2,prf_out,128);
        
        mpz_import(mpz_prf,sizeof(prf_out2),1,sizeof(prf_out2[0]),0,0, prf_out2);

      //  for (int j =0; j<1; j++){
      //  printf("\n The value of PRF for j = %d is %d for the i %d  \n",j, prf_out2[j],i);}
        mpz_init(c_pk[i]); // initialize the value of c_pk at i
        block_encrypt(c_pk[i],mpz_prf,kp); // encrypts the value of mpz_prf and stores it in c_pk[i]

// == == == == == == ** ** ** ** ** ** ** ** 
         mpz_invert(c_pk[i], c_pk[i], kp.n);
        counter++;
        

    }

	
	
	
	
    // =========================== Sign 
    
    unsigned char message[32] = {0x00};
    unsigned char h[32];
    unsigned char concatMsg[64] = {0x00};
    unsigned char hashedMsg[64] = {0x00};
    mpz_t r; // value to hold the prf output before enc in sign for r
    mpz_init(r);
    mpz_t R; // value to hold the prf output before enc in sign for R
    mpz_init(R);
    mpz_t s_i; // value to hold the sk component s_i
    mpz_init(s_i);
    mpz_t gamma; // value to hold the signature component \gamma
   // unsigned int one = 1;
    mpz_init(gamma);
    mpz_set_ui(gamma,1);
    
    ecbEncCounterMode(counter,1,prf_out); // To generate the randomness r 
    memcpy(prf_out2,prf_out,128);
    mpz_import(r,sizeof(prf_out2),1,sizeof(prf_out2[0]),0,0, prf_out2);
    block_encrypt(R, r, kp); // To generate R
    blake2b(h, R, NULL, sizeof(R),32,0); // Get the value of h from hash funtion
    strcpy(concatMsg, message); // Concatenate msg with h 
    memcpy(concatMsg+32, h, 32);  // Concatenate msg with h 
    blake2b(hashedMsg, concatMsg, NULL, 64,64,0);
   // printf("\n This is in the sign algo\n");
   // for (unsigned i = 0; i < 64; ++i) 
        //printf("The hash at %d is %x\n", i,hashedMsg[i] );
    for (unsigned i = 0; i < 26; ++i) {
        
        index = hashedMsg[2*i] + (floor(hashedMsg[2*i+1]/64) * 256);
      // printf(" The index is %d\n", index);
        ecbEncCounterMode(index,1,prf_out);
        memcpy(prf_out2,prf_out,128);
        mpz_import(s_i,sizeof(prf_out2),1,sizeof(prf_out2[0]),0,0, prf_out2);
        mpz_mul(gamma,s_i,gamma);
        printf(" The index is %d\n", index);

    }
    mpz_mul(gamma,r,gamma); // multiply the masking term
    mpz_mod(gamma,gamma,kp.n); // take the mod
    
    
    // =========================== Verify
    unsigned char concatMsg_vfy[64] = {0x00};
    unsigned char hashedMsg_vfy[64] = {0x00};
    mpz_t Gamma; // value to hold the signature component \gamma
    mpz_init(Gamma);
    mpz_set_ui(Gamma,1);
    mpz_t gamma_enc; // value to hold the signature component \gamma
    mpz_init(gamma_enc);
    mpz_t beta;
    mpz_init(beta);
    strcpy(concatMsg_vfy, message); // Concatenate msg with h 
    memcpy(concatMsg_vfy+32, h, 32);
    blake2b(hashedMsg_vfy, concatMsg_vfy, NULL, 64,64,0);
   // printf("\n\n\n This is in the Verify algo\n");
    //for (unsigned i = 0; i < 64; ++i) 
       // printf("The hash at %d is %x\n", i,hashedMsg_vfy[i] );
    for (unsigned j = 0; j < 26; ++j) {
        index_v = hashedMsg_vfy[2*j] + (floor(hashedMsg_vfy[2*j+1]/64) * 256);
        mpz_mul(Gamma,c_pk[index_v],Gamma);
        mpz_mod(Gamma,Gamma,kp.n); // take the mod

  printf("The index is %d\n", index_v);
    }
//  gmp_printf ("\n %s is an mpz for R %Zd\n", "here", R);
    block_encrypt(gamma_enc,gamma,kp); // encrypts the value of gamma
//  gmp_printf ("\n %s is an mpz for gamma %Zd\n", "here", gamma_enc);
    mpz_mul(beta, gamma_enc,Gamma);
    mpz_mod(beta,beta,kp.n);
//  gmp_printf ("\n %s is an mpz for gamma %Zd\n", "here", beta);
    if (mpz_cmp(R,beta) == 0)
		printf("SIGNATURE IS VERIFIED\n");
	else
		printf("SIGNATURE IS NOT VERIFIED\n");
    free(prf_out);
    free(prf_out2);
	return 0;
}
