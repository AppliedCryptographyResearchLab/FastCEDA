#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "params.h"
#include "blake2.h"
#include "aes.h"
#include "math.h"
#include <gmp.h>
#include <time.h>
 




// ======== RSA Stuff 











typedef struct {
    mpz_t n; /* Modulus */
    mpz_t e; /* Public Exponent */
} public_key;

typedef struct {
    mpz_t n; /* Modulus */
    mpz_t e; /* Public Exponent */
    mpz_t d; /* Private Exponent */
    mpz_t p; /* Starting prime p */
    mpz_t q; /* Starting prime q */
} private_key;

void print_hex(char* arr, int len)
{
    int i;
    for(i = 0; i < len; i++)
        printf("%02x", (unsigned char) arr[i]);
}

/* NOTE: Assumes mpz_t's are initted in ku and kp */
void generate_keys(private_key* ku, public_key* kp)
{
    char buf[BUFFER_SIZE];
    int i;
    mpz_t phi; mpz_init(phi);
    mpz_t tmp1; mpz_init(tmp1);
    mpz_t tmp2; mpz_init(tmp2);

    srand(time(NULL));

    /* Insetead of selecting e st. gcd(phi, e) = 1; 1 < e < phi, lets choose e
     * first then pick p,q st. gcd(e, p-1) = gcd(e, q-1) = 1 */
    // We'll set e globally.  I've seen suggestions to use primes like 3, 17 or
    // 65537, as they make coming calculations faster.  Lets use 3.
    mpz_set_ui(ku->e, 17);

    /* Select p and q */
    /* Start with p */
    // Set the bits of tmp randomly
    for(i = 0; i < BUFFER_SIZE; i++)
        buf[i] = rand() % 0xFF;
    // Set the top two bits to 1 to ensure int(tmp) is relatively large
    buf[0] |= 0xC0;
    // Set the bottom bit to 1 to ensure int(tmp) is odd (better for finding primes)
    buf[BUFFER_SIZE - 1] |= 0x01;
    // Interpret this char buffer as an int
    mpz_import(tmp1, BUFFER_SIZE, 1, sizeof(buf[0]), 0, 0, buf);
    // Pick the next prime starting from that random number
    mpz_nextprime(ku->p, tmp1);
    /* Make sure this is a good choice*/
    mpz_mod(tmp2, ku->p, ku->e);        /* If p mod e == 1, gcd(phi, e) != 1 */
    while(!mpz_cmp_ui(tmp2, 1))
    {
        mpz_nextprime(ku->p, ku->p);    /* so choose the next prime */
        mpz_mod(tmp2, ku->p, ku->e);
    }

    /* Now select q */
    do {
        for(i = 0; i < BUFFER_SIZE; i++)
            buf[i] = rand() % 0xFF;
        // Set the top two bits to 1 to ensure int(tmp) is relatively large
        buf[0] |= 0xC0;
        // Set the bottom bit to 1 to ensure int(tmp) is odd
        buf[BUFFER_SIZE - 1] |= 0x01;
        // Interpret this char buffer as an int
        mpz_import(tmp1, (BUFFER_SIZE), 1, sizeof(buf[0]), 0, 0, buf);
        // Pick the next prime starting from that random number
        mpz_nextprime(ku->q, tmp1);
        mpz_mod(tmp2, ku->q, ku->e);
        while(!mpz_cmp_ui(tmp2, 1))
        {
            mpz_nextprime(ku->q, ku->q);
            mpz_mod(tmp2, ku->q, ku->e);
        }
    } while(mpz_cmp(ku->p, ku->q) == 0); /* If we have identical primes (unlikely), try again */

    /* Calculate n = p x q */
    mpz_mul(ku->n, ku->p, ku->q);

    /* Compute phi(n) = (p-1)(q-1) */
    mpz_sub_ui(tmp1, ku->p, 1);
    mpz_sub_ui(tmp2, ku->q, 1);
    mpz_mul(phi, tmp1, tmp2);

    /* Calculate d (multiplicative inverse of e mod phi) */
    if(mpz_invert(ku->d, ku->e, phi) == 0)
    {
        mpz_gcd(tmp1, ku->e, phi);
        printf("gcd(e, phi) = [%s]\n", mpz_get_str(NULL, 16, tmp1));
        printf("Invert failed\n");
    }

    /* Set public key */
    mpz_set(kp->e, ku->e);
    mpz_set(kp->n, ku->n);

    return;
}

void block_encrypt(mpz_t C, mpz_t M, public_key kp)
{
    /* C = M^e mod n */
    mpz_powm(C, M, kp.e, kp.n);
    return;
}

int encrypt(char cipher[], char message[], int length, public_key kp)
{
    /* Its probably overkill, but I implemented PKCS#1v1.5 paging
     * Encoded message block is of the form:
     * EMB = 00 || 02 || PS || 00 || D
     * Where || is concatenation, D is the message, and PS is a string of
     * (block_size-|D|-3) non-zero, randomly generated bytes
     * |D| must be less than block_size - 11, which means we have at least 8
     * bytes of PS
     */
    int block_count = 0;
    int prog = length;
    char mess_block[BLOCK_SIZE];
    mpz_t m; mpz_init(m);
    mpz_t c; mpz_init(c);

    while(prog > 0)
    {
        int i = 0;
        int d_len = (prog >= (BLOCK_SIZE - 11)) ? BLOCK_SIZE - 11 : prog;

        /* Construct the header */
        mess_block[i++] = 0x00;
        mess_block[i++] = 0x02;
        while(i < (BLOCK_SIZE - d_len - 1))
            mess_block[i++] = (rand() % (0xFF - 1)) + 1;
        mess_block[i++] = 0x00;

        /* Copy in the message */
        memcpy(mess_block + i, message + (length - prog), d_len);

        // Convert bytestream to integer
        mpz_import(m, BLOCK_SIZE, 1, sizeof(mess_block[0]), 0, 0, mess_block);
        // Perform encryption on that block
        block_encrypt(c, m, kp);

        // Calculate cipher write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = block_count * BLOCK_SIZE;         // Base offset to start of this block
        off += (BLOCK_SIZE - (mpz_sizeinbase(c, 2) + 8 - 1)/8); // See manual for mpz_export

        // Pull out bytestream of ciphertext
        mpz_export(cipher + off, NULL, 1, sizeof(char), 0, 0, c);

        block_count++;
        prog -= d_len;
    }
    return block_count * BLOCK_SIZE;
}

void block_decrypt(mpz_t M, mpz_t C, private_key ku)
{
    mpz_powm(M, C, ku.d, ku.n);
    return;
}

int decrypt(char* message, char* cipher, int length, private_key ku)
{
    int msg_idx = 0;
    char buf[BLOCK_SIZE];
    *(long long*)buf = 0ll;
    mpz_t c; mpz_init(c);
    mpz_t m; mpz_init(m);

    int i;
    for(i = 0; i < (length / BLOCK_SIZE); i++)
    {
        // Pull block into mpz_t
        mpz_import(c, BLOCK_SIZE, 1, sizeof(char), 0, 0, cipher + i * BLOCK_SIZE);
        // Decrypt block
        block_decrypt(m, c, ku);

        // Calculate message write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = (BLOCK_SIZE - (mpz_sizeinbase(m, 2) + 8 - 1)/8); // See manual for mpz_export
        // Convert back to bitstream
        mpz_export(buf + off, NULL, 1, sizeof(char), 0, 0, m);

        // Now we just need to lop off top padding before memcpy-ing to message
        // We know the first 2 bytes are 0x00 and 0x02, so manually skip those
        // After that, increment forward till we see a zero byte
        int j;
        for(j = 2; ((buf[j] != 0) && (j < BLOCK_SIZE)); j++);
        j++;        // Skip the 00 byte

        /* Copy over the message part of the plaintext to the message return var */
        memcpy(message + msg_idx, buf + j, BLOCK_SIZE - j);

        msg_idx += BLOCK_SIZE - j;
    }
    return msg_idx;
}




//  ==================== RSA Code 


//
//void init_aes(unsigned char *sk){ 	// initialize the aes function with the key sk
//
//    block key;
//	key = toBlock((uint8_t*)sk);
//	setKey(key);
//    
//    return;
//
//    }
    
    
//void sig_KeyGen(public_key kp, mpz_t*  c_pk){
//    
//    //init_aes(sk);
//
//    block* prf_out;
//    uint16_t* prf_out2;
//	prf_out = malloc(16*16);
//	prf_out2 = malloc(16*16);
//    uint64_t i = 0;
//    mpz_t mpz_prf; // value to hold the prf output before enc in keyGen
//    mpz_init(mpz_prf);
//
//    for ( i = 0;i<1024;i++){
//  
//        ecbEncCounterMode(i,16,prf_out);
// 
//        memcpy(prf_out2,prf_out,SECRECT_SIZE);
// 
//        mpz_import(mpz_prf,SECRECT_SIZE,1,sizeof(prf_out2[0]),0,0, prf_out2);
//    
//
//          //  for (int j =0; j<1; j++){
//          //  printf("\n The value of PRF for j = %d is %d for the i %d  \n",j, prf_out2[j],i);}
//        mpz_init(c_pk[i]); // initialize the value of c_pk at i
//        block_encrypt(c_pk[i],mpz_prf,kp); // encrypts the value of mpz_prf and stores it in c_pk[i]
//
//    // == == == == == == ** ** ** ** ** ** ** ** 
//        mpz_invert(c_pk[i], c_pk[i], kp.n);
//        //counter++;
//            
//
//    }
//    gmp_printf("This is the value in the MAIN of pk %Zd\n ",c_pk[0]);
//
//    free(prf_out);
//    free(prf_out2);
//    return;
//}

    private_key ku;
    public_key kp;

int main( )
{
    // Timing variables 
    double SignTime, VerifyTime;
    SignTime = 0.0;
    VerifyTime = 0.0;
    clock_t flagSignStart, flagVerStart;
	clock_t flagSignEnd, flagVerEnd;    
    
    // Initialize public key
    mpz_init(kp.n);
    mpz_init(kp.e);
    // Initialize private key
    mpz_init(ku.n);
    mpz_init(ku.e);
    mpz_init(ku.d);
    mpz_init(ku.p);
    mpz_init(ku.q);
	const unsigned char sk[16] = {0x54, 0xa2, 0xf8, 0x03, 0x1d, 0x18, 0xac, 0x77, 0xd2, 0x53, 0x92, 0xf2, 0x80, 0xb4, 0xb1, 0x2f};
    generate_keys(&ku, &kp);

 
	block* prf_out;
    unsigned char * prf_out2;
	prf_out = malloc(16*16);
	prf_out2 = malloc(16*16);
	
    const unsigned char z[32] = {0x54, 0xa2, 0xf8, 0x03, 0x1d, 0x18, 0xac, 0x77, 0xd2, 0x53, 0x92, 0xf2, 0x80, 0xb4, 0xb1, 0x2f, 0xac, 0xf1, 0x29, 0x3f, 0x3a, 0xe6, 0x77, 0x7d, 0x74, 0x15, 0x67, 0x91, 0x99, 0x53, 0x69, 0xc5};
    mpz_t c_pk[1024];
    for ( int ij = 0;ij<1024;ij++)
        mpz_init(c_pk[ij]);
	uint64_t ii ,i;
	ii = 1;
	i = 0;
    block key;
	key = toBlock((uint8_t*)sk);
	setKey(key);
 
	uint64_t index;
    uint64_t index_v;

	uint64_t counter = 1025;
    
    
    // =========================== KeyGen 
    
    mpz_t mpz_prf; // value to hold the prf output before enc in keyGen
    mpz_init(mpz_prf);
  //  gmp_printf("This is the value in the MAIN of pk %Zd\n ",c_pk[0]);
///    sig_KeyGen(kp, &c_pk);
    
    
    
    for (i = 0;i<1024;i++){
      //  printf("\n\n\n for i =%d \n\n\n",i);
        ecbEncCounterMode(i,16,prf_out);
        memcpy(prf_out2,prf_out,32);
        mpz_import(mpz_prf,32 ,0,sizeof(prf_out2[0]),0,0, prf_out2);
        

      //  for (int j =0; j<1; j++){
      //  printf("\n The value of PRF for j = %d is %d for the i %d  \n",j, prf_out2[j],i);}
        mpz_init(c_pk[i]); // initialize the value of c_pk at i
        block_encrypt(c_pk[i],mpz_prf,kp); // encrypts the value of mpz_prf and stores it in c_pk[i]

// == == == == == == ** ** ** ** ** ** ** ** 
         mpz_invert(c_pk[i], c_pk[i], kp.n);
         mpz_mod(c_pk[i],c_pk[i],kp.n);
        // gmp_printf("This is the value in the main of pk %Zd\n ", ,c_pk[i]);
        counter++;
        

    }

	
	
	
	
    // =========================== Sign 
    
    uint8_t message[32] = {0};
    unsigned char h[32];
    unsigned char concatMsg[64] = {0x00};
    unsigned char hashedMsg[64] = {0x00};
    mpz_t r; // value to hold the prf output before enc in sign for r
    mpz_init(r);
    mpz_t R; // value to hold the prf output before enc in sign for R
    mpz_init(R);
    mpz_t s_i; // value to hold the sk component s_i
    mpz_init(s_i);
    mpz_t gamma; // value to hold the signature component \gamma
   // unsigned int one = 1;
    mpz_init(gamma);
    mpz_set_ui(gamma,1);
    unsigned char concatMsg_vfy[64] = {0x00};
    unsigned char hashedMsg_vfy[64] = {0x00};
    mpz_t Gamma; // value to hold the signature component \gamma
    mpz_init(Gamma);
    mpz_set_ui(Gamma,1);
    mpz_t gamma_enc; // value to hold the signature component \gamma
    mpz_init(gamma_enc);
    mpz_t beta;
    mpz_init(beta);
    int zz;
    for (zz = 0; zz < 100000; ++zz) {
        mpz_set_ui(gamma,1);
        
        
        flagSignStart = clock();
        ecbEncCounterMode(counter,16,prf_out); // To generate the randomness r 
       
        //counter++;
        memcpy(prf_out2,prf_out,32);
        
        mpz_import(r,32,0,sizeof(prf_out2[0]),0,0, prf_out2);
         
        mpz_mod(r,r,kp.n);
        block_encrypt(R, r, kp); // To generate R
      
        blake2b(h, R, NULL, sizeof(R),32,0); // Get the value of h from hash funtion
        strcpy(concatMsg, message); // Concatenate msg with h 
       
        //memcpy(concatMsg+32, h, 32);  // Concatenate msg with h 
       
        blake2b(hashedMsg, concatMsg, NULL, 64,64,0);
 
        for (unsigned i = 0; i < 18; ++i) {
          
         index = hashedMsg[2*i] + ((hashedMsg[2*i+1]/64) * 256);
           // index =  ((hashedMsg[2*i+1]/64) * 256);
          
          // printf(" The index is %d\n", index);
            ecbEncCounterMode(index,16,prf_out);
            memcpy(prf_out2,prf_out,32);
             
            mpz_import(s_i,32,0,sizeof(prf_out2[0]),0,0, prf_out2);
                        
           //   printf("This is the value in the main of pk %d\n ", mpz_sizeinbase(s_i, 2));
         // take the mod
          //  mpz_mod(s_i,s_i,kp.n);           
//mpz_mod(gamma,gamma,kp.n); 
            mpz_mul(gamma,s_i,gamma);
          //  mpz_mod(gamma,gamma,kp.n);           


        }
              
 
        mpz_mul(gamma,r,gamma); // multiply the masking term

        mpz_mod(gamma,gamma,kp.n); // take the mod
                   // printf(" The size of is prfout2 %d\n", mpz_size(s_i));

                flagSignEnd = clock();
        SignTime = SignTime +(double)(flagSignEnd-flagSignStart);
        
     
        // =========================== Verify
    //    unsigned char concatMsg_vfy[64] = {0x00};
    //    unsigned char hashedMsg_vfy[64] = {0x00};
    //    mpz_t Gamma; // value to hold the signature component \gamma
    //    mpz_init(Gamma);
    //    mpz_set_ui(Gamma,1);
    //    mpz_t gamma_enc; // value to hold the signature component \gamma
    //    mpz_init(gamma_enc);
    //    mpz_t beta;
    //    mpz_init(beta);
        strcpy(concatMsg_vfy, message); // Concatenate msg with h 
       // memcpy(concatMsg_vfy+32, h, 32);
        mpz_set_ui(Gamma,1);
        flagVerStart = clock();
        blake2b(hashedMsg_vfy, concatMsg_vfy, NULL, 64,64,0);
       // printf("\n\n\n This is in the Verify algo\n");
        //for (unsigned i = 0; i < 64; ++i) 
           // printf("The hash at %d is %x\n", i,hashedMsg_vfy[i] );
        for (unsigned j = 0; j < 18; ++j) {
           index_v = hashedMsg_vfy[2*j] + ((hashedMsg_vfy[2*j+1]/64) * 256);
         //  index_v =  ((hashedMsg_vfy[2*j+1]/64) * 256);
            mpz_mul(Gamma,c_pk[index_v],Gamma);
            mpz_mod(Gamma,Gamma,kp.n); // take the mod

     
        }
    //  gmp_printf ("\n %s is an mpz for R %Zd\n", "here", R);
        block_encrypt(gamma_enc,gamma,kp); // encrypts the value of gamma
    //  gmp_printf ("\n %s is an mpz for gamma %Zd\n", "here", gamma_enc);
        mpz_mul(beta, gamma_enc,Gamma);
        mpz_mod(beta,beta,kp.n);
        flagVerEnd = clock();
		VerifyTime = VerifyTime + (double)(flagVerEnd-flagVerStart);

    }

//  gmp_printf ("\n %s is an mpz for gamma %Zd\n", "here", beta);
    if (mpz_cmp(R,beta) == 0)
		printf("SIGNATURE IS VERIFIED\n");
	else
		printf("SIGNATURE IS NOT VERIFIED\n");
        
    printf("Parameters:\n");
	printf("|N| = %d\n", MODULUS_SIZE);
	gmp_printf("e = %x\n", kp.e);
   // printf("%fus per sign\n", ((double) (SignTime)));
	printf("%fus per sign\n", ((double) (SignTime * 1000)) / CLOCKS_PER_SEC / zz * 1000);
	printf("%fus per verification\n", ((double) (VerifyTime * 1000)) / CLOCKS_PER_SEC / zz * 1000);
	printf("%fus end-to-end delay\n", ((double) ((SignTime+VerifyTime) * 1000)) / CLOCKS_PER_SEC / zz * 1000);
    free(prf_out);
    free(prf_out2);
	return 0;
}
